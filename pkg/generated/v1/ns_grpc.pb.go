// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package nameserver

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// NameServerClient is the client API for NameServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NameServerClient interface {
	CreateCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error)
	DeleteCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error)
	ListCells(ctx context.Context, in *ListCellsRequest, opts ...grpc.CallOption) (*ListCellsReply, error)
	ListPlayersInCell(ctx context.Context, in *ListPlayersRequest, opts ...grpc.CallOption) (*PlayersReply, error)
	RequestCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterReply, error)
	UnregisterCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterStatusReply, error)
	PlayerLeftCell(ctx context.Context, in *PlayerLeftCellRequest, opts ...grpc.CallOption) (*PlayerStatusReply, error)
	RequestCellNeighbours(ctx context.Context, in *CellNeighbourRequest, opts ...grpc.CallOption) (*CellNeighboursReply, error)
	RequestCellSizeChange(ctx context.Context, in *CellChangeSizeRequest, opts ...grpc.CallOption) (*CellChangeStatusReply, error)
	LockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error)
	UnlockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error)
}

type nameServerClient struct {
	cc grpc.ClientConnInterface
}

func NewNameServerClient(cc grpc.ClientConnInterface) NameServerClient {
	return &nameServerClient{cc}
}

var nameServerCreateCellStreamDesc = &grpc.StreamDesc{
	StreamName: "CreateCell",
}

func (c *nameServerClient) CreateCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error) {
	out := new(CellStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/CreateCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerDeleteCellStreamDesc = &grpc.StreamDesc{
	StreamName: "DeleteCell",
}

func (c *nameServerClient) DeleteCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error) {
	out := new(CellStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/DeleteCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerListCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "ListCells",
}

func (c *nameServerClient) ListCells(ctx context.Context, in *ListCellsRequest, opts ...grpc.CallOption) (*ListCellsReply, error) {
	out := new(ListCellsReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/ListCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerListPlayersInCellStreamDesc = &grpc.StreamDesc{
	StreamName: "ListPlayersInCell",
}

func (c *nameServerClient) ListPlayersInCell(ctx context.Context, in *ListPlayersRequest, opts ...grpc.CallOption) (*PlayersReply, error) {
	out := new(PlayersReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/ListPlayersInCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerRequestCellMasterStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellMaster",
}

func (c *nameServerClient) RequestCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterReply, error) {
	out := new(CellMasterReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/RequestCellMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerUnregisterCellMasterStreamDesc = &grpc.StreamDesc{
	StreamName: "UnregisterCellMaster",
}

func (c *nameServerClient) UnregisterCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterStatusReply, error) {
	out := new(CellMasterStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/UnregisterCellMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerPlayerLeftCellStreamDesc = &grpc.StreamDesc{
	StreamName: "PlayerLeftCell",
}

func (c *nameServerClient) PlayerLeftCell(ctx context.Context, in *PlayerLeftCellRequest, opts ...grpc.CallOption) (*PlayerStatusReply, error) {
	out := new(PlayerStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/PlayerLeftCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerRequestCellNeighboursStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellNeighbours",
}

func (c *nameServerClient) RequestCellNeighbours(ctx context.Context, in *CellNeighbourRequest, opts ...grpc.CallOption) (*CellNeighboursReply, error) {
	out := new(CellNeighboursReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/RequestCellNeighbours", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerRequestCellSizeChangeStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellSizeChange",
}

func (c *nameServerClient) RequestCellSizeChange(ctx context.Context, in *CellChangeSizeRequest, opts ...grpc.CallOption) (*CellChangeStatusReply, error) {
	out := new(CellChangeStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/RequestCellSizeChange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerLockCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "LockCells",
}

func (c *nameServerClient) LockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error) {
	out := new(CellLockStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/LockCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var nameServerUnlockCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "UnlockCells",
}

func (c *nameServerClient) UnlockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error) {
	out := new(CellLockStatusReply)
	err := c.cc.Invoke(ctx, "/nameserver.NameServer/UnlockCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NameServerService is the service API for NameServer service.
// Fields should be assigned to their respective handler implementations only before
// RegisterNameServerService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type NameServerService struct {
	CreateCell            func(context.Context, *CellRequest) (*CellStatusReply, error)
	DeleteCell            func(context.Context, *CellRequest) (*CellStatusReply, error)
	ListCells             func(context.Context, *ListCellsRequest) (*ListCellsReply, error)
	ListPlayersInCell     func(context.Context, *ListPlayersRequest) (*PlayersReply, error)
	RequestCellMaster     func(context.Context, *CellMasterRequest) (*CellMasterReply, error)
	UnregisterCellMaster  func(context.Context, *CellMasterRequest) (*CellMasterStatusReply, error)
	PlayerLeftCell        func(context.Context, *PlayerLeftCellRequest) (*PlayerStatusReply, error)
	RequestCellNeighbours func(context.Context, *CellNeighbourRequest) (*CellNeighboursReply, error)
	RequestCellSizeChange func(context.Context, *CellChangeSizeRequest) (*CellChangeStatusReply, error)
	LockCells             func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error)
	UnlockCells           func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error)
}

func (s *NameServerService) createCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.CreateCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/CreateCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.CreateCell(ctx, req.(*CellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) deleteCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.DeleteCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/DeleteCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.DeleteCell(ctx, req.(*CellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) listCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/ListCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListCells(ctx, req.(*ListCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) listPlayersInCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlayersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListPlayersInCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/ListPlayersInCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListPlayersInCell(ctx, req.(*ListPlayersRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) requestCellMaster(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/RequestCellMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellMaster(ctx, req.(*CellMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) unregisterCellMaster(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UnregisterCellMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/UnregisterCellMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UnregisterCellMaster(ctx, req.(*CellMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) playerLeftCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerLeftCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.PlayerLeftCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/PlayerLeftCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.PlayerLeftCell(ctx, req.(*PlayerLeftCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) requestCellNeighbours(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellNeighbourRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellNeighbours(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/RequestCellNeighbours",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellNeighbours(ctx, req.(*CellNeighbourRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) requestCellSizeChange(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellChangeSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellSizeChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/RequestCellSizeChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellSizeChange(ctx, req.(*CellChangeSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) lockCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.LockCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/LockCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.LockCells(ctx, req.(*LockCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *NameServerService) unlockCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UnlockCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/nameserver.NameServer/UnlockCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UnlockCells(ctx, req.(*LockCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterNameServerService registers a service implementation with a gRPC server.
func RegisterNameServerService(s grpc.ServiceRegistrar, srv *NameServerService) {
	srvCopy := *srv
	if srvCopy.CreateCell == nil {
		srvCopy.CreateCell = func(context.Context, *CellRequest) (*CellStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method CreateCell not implemented")
		}
	}
	if srvCopy.DeleteCell == nil {
		srvCopy.DeleteCell = func(context.Context, *CellRequest) (*CellStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method DeleteCell not implemented")
		}
	}
	if srvCopy.ListCells == nil {
		srvCopy.ListCells = func(context.Context, *ListCellsRequest) (*ListCellsReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListCells not implemented")
		}
	}
	if srvCopy.ListPlayersInCell == nil {
		srvCopy.ListPlayersInCell = func(context.Context, *ListPlayersRequest) (*PlayersReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListPlayersInCell not implemented")
		}
	}
	if srvCopy.RequestCellMaster == nil {
		srvCopy.RequestCellMaster = func(context.Context, *CellMasterRequest) (*CellMasterReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellMaster not implemented")
		}
	}
	if srvCopy.UnregisterCellMaster == nil {
		srvCopy.UnregisterCellMaster = func(context.Context, *CellMasterRequest) (*CellMasterStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UnregisterCellMaster not implemented")
		}
	}
	if srvCopy.PlayerLeftCell == nil {
		srvCopy.PlayerLeftCell = func(context.Context, *PlayerLeftCellRequest) (*PlayerStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method PlayerLeftCell not implemented")
		}
	}
	if srvCopy.RequestCellNeighbours == nil {
		srvCopy.RequestCellNeighbours = func(context.Context, *CellNeighbourRequest) (*CellNeighboursReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellNeighbours not implemented")
		}
	}
	if srvCopy.RequestCellSizeChange == nil {
		srvCopy.RequestCellSizeChange = func(context.Context, *CellChangeSizeRequest) (*CellChangeStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellSizeChange not implemented")
		}
	}
	if srvCopy.LockCells == nil {
		srvCopy.LockCells = func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method LockCells not implemented")
		}
	}
	if srvCopy.UnlockCells == nil {
		srvCopy.UnlockCells = func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UnlockCells not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "nameserver.NameServer",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "CreateCell",
				Handler:    srvCopy.createCell,
			},
			{
				MethodName: "DeleteCell",
				Handler:    srvCopy.deleteCell,
			},
			{
				MethodName: "ListCells",
				Handler:    srvCopy.listCells,
			},
			{
				MethodName: "ListPlayersInCell",
				Handler:    srvCopy.listPlayersInCell,
			},
			{
				MethodName: "RequestCellMaster",
				Handler:    srvCopy.requestCellMaster,
			},
			{
				MethodName: "UnregisterCellMaster",
				Handler:    srvCopy.unregisterCellMaster,
			},
			{
				MethodName: "PlayerLeftCell",
				Handler:    srvCopy.playerLeftCell,
			},
			{
				MethodName: "RequestCellNeighbours",
				Handler:    srvCopy.requestCellNeighbours,
			},
			{
				MethodName: "RequestCellSizeChange",
				Handler:    srvCopy.requestCellSizeChange,
			},
			{
				MethodName: "LockCells",
				Handler:    srvCopy.lockCells,
			},
			{
				MethodName: "UnlockCells",
				Handler:    srvCopy.unlockCells,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "ns.proto",
	}

	s.RegisterService(&sd, nil)
}
