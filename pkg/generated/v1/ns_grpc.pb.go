// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package cellmanager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// CellManagerClient is the client API for CellManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CellManagerClient interface {
	CreateCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error)
	DeleteCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error)
	ListCells(ctx context.Context, in *ListCellsRequest, opts ...grpc.CallOption) (*ListCellsReply, error)
	ListPlayersInCell(ctx context.Context, in *ListPlayersRequest, opts ...grpc.CallOption) (*PlayersReply, error)
	RequestCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterReply, error)
	UnregisterCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterStatusReply, error)
	PlayerLeftCell(ctx context.Context, in *PlayerLeftCellRequest, opts ...grpc.CallOption) (*PlayerStatusReply, error)
	RequestCellNeighbours(ctx context.Context, in *CellNeighbourRequest, opts ...grpc.CallOption) (*CellNeighboursReply, error)
	RequestCellSizeChange(ctx context.Context, in *CellChangeSizeRequest, opts ...grpc.CallOption) (*CellChangeStatusReply, error)
	LockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error)
	UnlockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error)
}

type cellManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewCellManagerClient(cc grpc.ClientConnInterface) CellManagerClient {
	return &cellManagerClient{cc}
}

var cellManagerCreateCellStreamDesc = &grpc.StreamDesc{
	StreamName: "CreateCell",
}

func (c *cellManagerClient) CreateCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error) {
	out := new(CellStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/CreateCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerDeleteCellStreamDesc = &grpc.StreamDesc{
	StreamName: "DeleteCell",
}

func (c *cellManagerClient) DeleteCell(ctx context.Context, in *CellRequest, opts ...grpc.CallOption) (*CellStatusReply, error) {
	out := new(CellStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/DeleteCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerListCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "ListCells",
}

func (c *cellManagerClient) ListCells(ctx context.Context, in *ListCellsRequest, opts ...grpc.CallOption) (*ListCellsReply, error) {
	out := new(ListCellsReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/ListCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerListPlayersInCellStreamDesc = &grpc.StreamDesc{
	StreamName: "ListPlayersInCell",
}

func (c *cellManagerClient) ListPlayersInCell(ctx context.Context, in *ListPlayersRequest, opts ...grpc.CallOption) (*PlayersReply, error) {
	out := new(PlayersReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/ListPlayersInCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerRequestCellMasterStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellMaster",
}

func (c *cellManagerClient) RequestCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterReply, error) {
	out := new(CellMasterReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/RequestCellMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerUnregisterCellMasterStreamDesc = &grpc.StreamDesc{
	StreamName: "UnregisterCellMaster",
}

func (c *cellManagerClient) UnregisterCellMaster(ctx context.Context, in *CellMasterRequest, opts ...grpc.CallOption) (*CellMasterStatusReply, error) {
	out := new(CellMasterStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/UnregisterCellMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerPlayerLeftCellStreamDesc = &grpc.StreamDesc{
	StreamName: "PlayerLeftCell",
}

func (c *cellManagerClient) PlayerLeftCell(ctx context.Context, in *PlayerLeftCellRequest, opts ...grpc.CallOption) (*PlayerStatusReply, error) {
	out := new(PlayerStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/PlayerLeftCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerRequestCellNeighboursStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellNeighbours",
}

func (c *cellManagerClient) RequestCellNeighbours(ctx context.Context, in *CellNeighbourRequest, opts ...grpc.CallOption) (*CellNeighboursReply, error) {
	out := new(CellNeighboursReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/RequestCellNeighbours", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerRequestCellSizeChangeStreamDesc = &grpc.StreamDesc{
	StreamName: "RequestCellSizeChange",
}

func (c *cellManagerClient) RequestCellSizeChange(ctx context.Context, in *CellChangeSizeRequest, opts ...grpc.CallOption) (*CellChangeStatusReply, error) {
	out := new(CellChangeStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/RequestCellSizeChange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerLockCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "LockCells",
}

func (c *cellManagerClient) LockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error) {
	out := new(CellLockStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/LockCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cellManagerUnlockCellsStreamDesc = &grpc.StreamDesc{
	StreamName: "UnlockCells",
}

func (c *cellManagerClient) UnlockCells(ctx context.Context, in *LockCellsRequest, opts ...grpc.CallOption) (*CellLockStatusReply, error) {
	out := new(CellLockStatusReply)
	err := c.cc.Invoke(ctx, "/cellmanager.CellManager/UnlockCells", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CellManagerService is the service API for CellManager service.
// Fields should be assigned to their respective handler implementations only before
// RegisterCellManagerService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type CellManagerService struct {
	CreateCell            func(context.Context, *CellRequest) (*CellStatusReply, error)
	DeleteCell            func(context.Context, *CellRequest) (*CellStatusReply, error)
	ListCells             func(context.Context, *ListCellsRequest) (*ListCellsReply, error)
	ListPlayersInCell     func(context.Context, *ListPlayersRequest) (*PlayersReply, error)
	RequestCellMaster     func(context.Context, *CellMasterRequest) (*CellMasterReply, error)
	UnregisterCellMaster  func(context.Context, *CellMasterRequest) (*CellMasterStatusReply, error)
	PlayerLeftCell        func(context.Context, *PlayerLeftCellRequest) (*PlayerStatusReply, error)
	RequestCellNeighbours func(context.Context, *CellNeighbourRequest) (*CellNeighboursReply, error)
	RequestCellSizeChange func(context.Context, *CellChangeSizeRequest) (*CellChangeStatusReply, error)
	LockCells             func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error)
	UnlockCells           func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error)
}

func (s *CellManagerService) createCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.CreateCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/CreateCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.CreateCell(ctx, req.(*CellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) deleteCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.DeleteCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/DeleteCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.DeleteCell(ctx, req.(*CellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) listCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/ListCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListCells(ctx, req.(*ListCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) listPlayersInCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlayersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListPlayersInCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/ListPlayersInCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListPlayersInCell(ctx, req.(*ListPlayersRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) requestCellMaster(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/RequestCellMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellMaster(ctx, req.(*CellMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) unregisterCellMaster(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UnregisterCellMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/UnregisterCellMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UnregisterCellMaster(ctx, req.(*CellMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) playerLeftCell(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerLeftCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.PlayerLeftCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/PlayerLeftCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.PlayerLeftCell(ctx, req.(*PlayerLeftCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) requestCellNeighbours(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellNeighbourRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellNeighbours(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/RequestCellNeighbours",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellNeighbours(ctx, req.(*CellNeighbourRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) requestCellSizeChange(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CellChangeSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.RequestCellSizeChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/RequestCellSizeChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.RequestCellSizeChange(ctx, req.(*CellChangeSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) lockCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.LockCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/LockCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.LockCells(ctx, req.(*LockCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CellManagerService) unlockCells(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockCellsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UnlockCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/cellmanager.CellManager/UnlockCells",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UnlockCells(ctx, req.(*LockCellsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterCellManagerService registers a service implementation with a gRPC server.
func RegisterCellManagerService(s grpc.ServiceRegistrar, srv *CellManagerService) {
	srvCopy := *srv
	if srvCopy.CreateCell == nil {
		srvCopy.CreateCell = func(context.Context, *CellRequest) (*CellStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method CreateCell not implemented")
		}
	}
	if srvCopy.DeleteCell == nil {
		srvCopy.DeleteCell = func(context.Context, *CellRequest) (*CellStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method DeleteCell not implemented")
		}
	}
	if srvCopy.ListCells == nil {
		srvCopy.ListCells = func(context.Context, *ListCellsRequest) (*ListCellsReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListCells not implemented")
		}
	}
	if srvCopy.ListPlayersInCell == nil {
		srvCopy.ListPlayersInCell = func(context.Context, *ListPlayersRequest) (*PlayersReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListPlayersInCell not implemented")
		}
	}
	if srvCopy.RequestCellMaster == nil {
		srvCopy.RequestCellMaster = func(context.Context, *CellMasterRequest) (*CellMasterReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellMaster not implemented")
		}
	}
	if srvCopy.UnregisterCellMaster == nil {
		srvCopy.UnregisterCellMaster = func(context.Context, *CellMasterRequest) (*CellMasterStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UnregisterCellMaster not implemented")
		}
	}
	if srvCopy.PlayerLeftCell == nil {
		srvCopy.PlayerLeftCell = func(context.Context, *PlayerLeftCellRequest) (*PlayerStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method PlayerLeftCell not implemented")
		}
	}
	if srvCopy.RequestCellNeighbours == nil {
		srvCopy.RequestCellNeighbours = func(context.Context, *CellNeighbourRequest) (*CellNeighboursReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellNeighbours not implemented")
		}
	}
	if srvCopy.RequestCellSizeChange == nil {
		srvCopy.RequestCellSizeChange = func(context.Context, *CellChangeSizeRequest) (*CellChangeStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method RequestCellSizeChange not implemented")
		}
	}
	if srvCopy.LockCells == nil {
		srvCopy.LockCells = func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method LockCells not implemented")
		}
	}
	if srvCopy.UnlockCells == nil {
		srvCopy.UnlockCells = func(context.Context, *LockCellsRequest) (*CellLockStatusReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UnlockCells not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "cellmanager.CellManager",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "CreateCell",
				Handler:    srvCopy.createCell,
			},
			{
				MethodName: "DeleteCell",
				Handler:    srvCopy.deleteCell,
			},
			{
				MethodName: "ListCells",
				Handler:    srvCopy.listCells,
			},
			{
				MethodName: "ListPlayersInCell",
				Handler:    srvCopy.listPlayersInCell,
			},
			{
				MethodName: "RequestCellMaster",
				Handler:    srvCopy.requestCellMaster,
			},
			{
				MethodName: "UnregisterCellMaster",
				Handler:    srvCopy.unregisterCellMaster,
			},
			{
				MethodName: "PlayerLeftCell",
				Handler:    srvCopy.playerLeftCell,
			},
			{
				MethodName: "RequestCellNeighbours",
				Handler:    srvCopy.requestCellNeighbours,
			},
			{
				MethodName: "RequestCellSizeChange",
				Handler:    srvCopy.requestCellSizeChange,
			},
			{
				MethodName: "LockCells",
				Handler:    srvCopy.lockCells,
			},
			{
				MethodName: "UnlockCells",
				Handler:    srvCopy.unlockCells,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "ns.proto",
	}

	s.RegisterService(&sd, nil)
}
